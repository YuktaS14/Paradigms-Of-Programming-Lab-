
structure A :  (* Transparent signature *)
          sig type t
              val pub : t
          end
= struct
     type t = int
     val pub = 42
     val prv = 100
end
(*val z = A.pub + A.pub
*)
structure B :>  (* Opaque/translucent signature *)
          sig type t
              type t1 = int
              val pub : t
			    
                  val pub1 : t1
          end
= struct
     type t = int
     type t1 = int
     val pub  = 42

     val pub1 = pub + pub
     val prv = 100
end
(* val z1 = B.pub + B.pub (* error *) *)
val z11 = B.pub1 + B.pub1 (* not
                   an error *)
val z2 = B.pub




 fun hash_string (x : string) : int = 0  (* A good hash function *)
 signature ATOM = sig
   type atom
   val atom : string -> atom
   val toString : atom -> string
   val compare  : atom * atom -> order
 end

 structure Atom1 :> ATOM = struct
    type atom               = { hashcode : int , symbol : string }
    fun atom x              = { symbol = x , hashcode = hash_string x }

    (* If hash_string is a good hash function then very likely
       the hash values of different strings are different *)


    fun toString (a : atom) = #symbol a
                                    (* Note that toString (atom x) = x *)
    fun compare (a1 : atom , a2 : atom)  =
        case Int.compare  (#hashcode a1 , #hashcode a2) of
             EQUAL => String.compare ( #symbol a1 , #symbol a2)
           | x     => x

                                    (* The comparison is fast  because it is int comparison *)
 end


(*
  Benign side effect, i.e observationally pure computation *)
(*
 structure Atom2 :> ATOM = struct

    type atom               = { hashcode : int , symbol : string }


    val counter = ref 0    (* We have a counter which will be used to assign hash codes *)
    val ht : atom StringHashTable.hash_table = IntHashTable.mkTable (100, exn)

    fun mkAtom x              = let val cur = !counter
                                    val atm = { symbol = x , hashcode = cur }
                                in counter := cur + 1;
                                   StringHashTable.insert ht (x, atm);
                                   atm
                                end

    fun atom x = case StringHashTable.find ht x of
                     NONE => mkAtom x
                  | SOME a => a


    fun toString (a : atom) = #symbol a
                                    (* Note that toString (atom x) = x *)
    fun compare (a1 : atom , a2 : atom)  = Int.compare  (#hashcode a1 , #hashcode a2)

                                    (* The comparison is fast  because it is int comparison *)
 end
*)
